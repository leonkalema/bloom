/**
 * adaptive-bloom-filter v1.1.0 - Browser Bundle
 * Fast, memory-efficient bloom filter with compression
 * https://github.com/leonkalema/bloom
 * MIT License
 */
(function(global){"use strict";const HashFunctions=(()=>{const murmur3=(key,seed=0)=>{if(typeof key!=="string")throw new Error("Hash key must be a string");const remainder=key.length&3,bytes=key.length-remainder;let h1=seed;const c1=0xcc9e2d51,c2=0x1b873593;let i=0;while(i<bytes){let k1=((key.charCodeAt(i)&0xff))|((key.charCodeAt(++i)&0xff)<<8)|((key.charCodeAt(++i)&0xff)<<16)|((key.charCodeAt(++i)&0xff)<<24);++i;k1=((((k1&0xffff)*c1)+((((k1>>>16)*c1)&0xffff)<<16)))&0xffffffff;k1=(k1<<15)|(k1>>>17);k1=((((k1&0xffff)*c2)+((((k1>>>16)*c2)&0xffff)<<16)))&0xffffffff;h1^=k1;h1=(h1<<13)|(h1>>>19);h1=((((h1&0xffff)*5)+((((h1>>>16)*5)&0xffff)<<16)))&0xffffffff;h1=(((h1&0xffff)+0x6b64)+((((h1>>>16)+0xe654)&0xffff)<<16))}let k1=0;switch(remainder){case 3:k1^=(key.charCodeAt(i+2)&0xff)<<16;case 2:k1^=(key.charCodeAt(i+1)&0xff)<<8;case 1:k1^=(key.charCodeAt(i)&0xff);k1=(((k1&0xffff)*c1)+((((k1>>>16)*c1)&0xffff)<<16))&0xffffffff;k1=(k1<<15)|(k1>>>17);k1=(((k1&0xffff)*c2)+((((k1>>>16)*c2)&0xffff)<<16))&0xffffffff;h1^=k1}h1^=key.length;h1^=h1>>>16;h1=(((h1&0xffff)*0x85ebca6b)+((((h1>>>16)*0x85ebca6b)&0xffff)<<16))&0xffffffff;h1^=h1>>>13;h1=((((h1&0xffff)*0xc2b2ae35)+((((h1>>>16)*0xc2b2ae35)&0xffff)<<16)))&0xffffffff;h1^=h1>>>16;return h1>>>0};const generateHashes=(item,numHashes,size)=>{if(typeof item!=="string")throw new Error("Item must be a string");const hashes=[],hash1=murmur3(item,0),hash2=murmur3(item,hash1);for(let i=0;i<numHashes;i++){hashes.push(Math.abs((hash1+i*hash2)%size))}return hashes};return{murmur3,generateHashes}})();const CompressibleBitArray=(()=>{const create=(size)=>{if(!Number.isInteger(size)||size<=0)throw new Error("Size must be a positive integer");return{array:new Uint8Array(Math.ceil(size/8)),size,compressed:false,compressionRatio:1}};const setBit=(bitArray,index)=>{if(bitArray.compressed){const expanded=expand(bitArray);bitArray.array=expanded.array;bitArray.compressed=false;bitArray.compressionRatio=1}const byteIndex=Math.floor(index/8),bitIndex=index%8;bitArray.array[byteIndex]|=(1<<bitIndex)};const getBit=(bitArray,index)=>{if(bitArray.compressed){const expanded=expand(bitArray);return getBit(expanded,index)}const byteIndex=Math.floor(index/8),bitIndex=index%8;return(bitArray.array[byteIndex]&(1<<bitIndex))!==0};const compress=(bitArray)=>{if(bitArray.compressed)return bitArray;const compressed=[];let currentByte=bitArray.array[0],count=1;for(let i=1;i<bitArray.array.length;i++){if(bitArray.array[i]===currentByte&&count<255){count++}else{compressed.push(currentByte,count);currentByte=bitArray.array[i];count=1}}if(count>0)compressed.push(currentByte,count);const compressedArray=new Uint8Array(compressed);return{array:compressedArray,size:bitArray.size,compressed:true,compressionRatio:bitArray.array.length/compressedArray.length}};const expand=(bitArray)=>{if(!bitArray.compressed)return bitArray;const originalSize=Math.ceil(bitArray.size/8),expanded=new Uint8Array(originalSize);let expandedIndex=0;for(let i=0;i<bitArray.array.length;i+=2){const value=bitArray.array[i],count=bitArray.array[i+1];for(let j=0;j<count;j++)expanded[expandedIndex++]=value}return{array:expanded,size:bitArray.size,compressed:false,compressionRatio:1}};const shouldCompress=(bitArray)=>{if(!bitArray||bitArray.compressed||bitArray.array.length<100)return false;let runs=0,currentByte=bitArray.array[0];for(let i=1;i<bitArray.array.length;i++){if(bitArray.array[i]!==currentByte){runs++;currentByte=bitArray.array[i]}}return runs*2<bitArray.array.length*0.8};return{create,setBit,getBit,compress,expand,shouldCompress}})();class AdaptiveBloomFilter{constructor(expectedItems,falsePositiveRate=0.01,options={}){if(!Number.isInteger(expectedItems)||expectedItems<=0)throw new Error("Expected items must be a positive integer");if(typeof falsePositiveRate!=="number"||falsePositiveRate<=0||falsePositiveRate>=1)throw new Error("False positive rate must be between 0 and 1");this.expectedItems=expectedItems;this.falsePositiveRate=falsePositiveRate;const m=Math.ceil((-expectedItems*Math.log(falsePositiveRate))/(Math.log(2)*Math.log(2)));const k=Math.round((m/expectedItems)*Math.log(2));this.size=m;this.hashFunctions=Math.max(1,k);this.bitArray=CompressibleBitArray.create(this.size);this.itemCount=0;this.metricsEnabled=options.metricsEnabled!==false;this.metrics={addOperations:0,checkOperations:0,falsePositives:0};this.compressionTimer=null}add(item){if(typeof item!=="string")throw new Error("Item must be a string");const hashes=HashFunctions.generateHashes(item,this.hashFunctions,this.size);for(const hash of hashes)CompressibleBitArray.setBit(this.bitArray,hash);this.itemCount++;if(this.metricsEnabled)this.metrics.addOperations++;this.scheduleCompression();return true}check(item){if(typeof item!=="string")throw new Error("Item must be a string");const hashes=HashFunctions.generateHashes(item,this.hashFunctions,this.size);for(const hash of hashes){if(!CompressibleBitArray.getBit(this.bitArray,hash))return false}if(this.metricsEnabled)this.metrics.checkOperations++;return true}addAsync(item){return Promise.resolve(this.add(item))}checkAsync(item){return Promise.resolve(this.check(item))}scheduleCompression(){if(this.compressionTimer)return;this.compressionTimer=setTimeout(()=>{this.compress();this.compressionTimer=null},1000)}compress(){if(!CompressibleBitArray.shouldCompress(this.bitArray))return false;this.bitArray=CompressibleBitArray.compress(this.bitArray);return true}reset(){if(this.compressionTimer){clearTimeout(this.compressionTimer);this.compressionTimer=null}this.bitArray=CompressibleBitArray.create(this.size);this.itemCount=0;this.metrics={addOperations:0,checkOperations:0,falsePositives:0}}getMetrics(){return this.metricsEnabled?{...this.metrics}:null}serialize(){return JSON.stringify({version:"1.1.0",expectedItems:this.expectedItems,falsePositiveRate:this.falsePositiveRate,size:this.size,hashFunctions:this.hashFunctions,itemCount:this.itemCount,bitArray:{array:Array.from(this.bitArray.array),size:this.bitArray.size,compressed:this.bitArray.compressed}})}static deserialize(data){const d=JSON.parse(data);const filter=new AdaptiveBloomFilter(d.expectedItems,d.falsePositiveRate);filter.bitArray={array:new Uint8Array(d.bitArray.array),size:d.bitArray.size,compressed:d.bitArray.compressed,compressionRatio:1};filter.itemCount=d.itemCount;return filter}}global.AdaptiveBloomFilter=AdaptiveBloomFilter;global.BloomFilter=AdaptiveBloomFilter;if(typeof module!=="undefined"&&module.exports){module.exports={AdaptiveBloomFilter}}})(typeof window!=="undefined"?window:typeof global!=="undefined"?global:this);
